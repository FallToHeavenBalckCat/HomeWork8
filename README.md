# HomeWork8
第七周作业
本周继续学习了dp的完全背包问题，对01背包问题有了更加深入的了解，同时复习了快速排序和归并排序以及整数二分和浮点数二分。其中在最佳牛围栏问题中了解了处理平均数的常用方式：所有的数字减去相同的均值，这样问题就从比较大小转换为了是否>=0的问题。同时继续学习了java的函数与类和对象以及Linux系统常用的文件管理命令以及文件结构。完全背包问题是在01背包问题上进行扩展：一件物品不仅可以取0,或1次，还可以取2,3...次，没有限制，求解在背包总体为V 的情况下所获得的物品的最大价值。会发现分析思路和0背包问题类似，如果还没有了解01背包问题，可以看我的这篇01背包详解：[01背包问题详解](https://blog.csdn.net/linjianshaonian_/article/details/126616612)这时写出的的代码应该是一个三重循环，因为还要枚举K的个数，因此我们要想办法优化掉一维，及使得状态转移方程和k无关：快排的几个步骤：
a. 确定分界点：q[l],q[r],q[l+r>>1];三个当中任选一个作为x
b.调整范围：确定一个x（这个x可以是任意的），x左边的所有值是<=x 的，x右边的所有值是>=x的。
c. 递归处理左右两端.quick_sort(
核心是如何调整范围，下边介绍一种双指针的做法，不需要额外开辟空间，时间复杂度为O(N);
维护两个指针i和j,i开始指向最左边0，指向最右边（n-1）;
i指向的数字如果是<=x的，不用操作，让i指针向右移动直到遇到q[i]>x停下来，开始移动j指针，
同理，j指向的数字如果是>=x的，不用操作，让j指针向左边移动直到遇到q[i]<x停下来，此时i指向的数字>x理应放到右边，而j指向的数字<x理应放到左边，所以把i和j指向的数字交换一下swap(q[i],q[j]);
然后继续移动指针i,j向刚才那样，（因为这时i指向的数字又是<=x,j指向的数字又是>=x的了所以可以继续移动），直到指针i,j相遇为止，此时指针左边的所有数字<=x，右边的所有数字>=x;结束这一层的操作，继续递归的处理子问题即可（quick_sort(q,l,j）,quick_sort(q,j+1,r);归并排序同样属于分支思想的一种算法。
不同的是，快排是先处理当前区间，再递归处理子问题；而归并排序则是先递归处理子问题，再进行合并，合并过程中使用的是双指针算法。
归并排序的具体步骤：
1.固定的，取区间的中点作为划分标准(int mid=l+r>>1);
2.分别递归处理左右两个子区间(merge_sort(q,l,mid),merge_sort(q,mid+1,r))
3.合并处理好的子区间(**核心步骤):
采用双指针算法，并且需要开一个额外的数组(tmp)保存合并后的结果：
int i=l,j=mid+1;
while(i<=mid&&j<=r)
	if(q[i]<=q[j]) tmp[k++]=q[i++];
	else  tmp[k++]=q[j++];
4.当一个指针走到尽头的时候，把另一个指针后边的数字也全部放到tmp数组中，
while(i<=mid) tmp[k++]=q[i++];
while(j<=r) tmp[k++]=q[j++];
5.把处理好之后的数组赋给原数组q.
for(i=l,j=r;i<=r;i++,j++) q[i]=tmp[j];
